;/* PROGRAM TO COUNT THE NUMBER OF ONES & ZEROS IN TWO CONSECUTIVE MEMORY LOCATIONS
;/* WE TOOK TWO NUMBERS i.e. 0X11111111,0XAA55AA55	(R0)*/
;/* CHECK THE RESULT IN R2 FOR ONES & R3 FOR ZEROS*/
;/* SET A BREAKPOINT AT NOP INSTRUCTION,RUN THE PROGRAM & CHECK THE RESULT */ 


  	AREA  ONEZERO , CODE, READONLY

ENTRY				;Mark first instruction to execute

START
	
	MOV R2,#0		; COUNTER FOR ONES
	MOV R3,#0		; COUNTER FOR ZEROS
	MOV R7,#2		; COUNTER TO GET TWO WORDS
	LDR R6,=VALUE 		; LOADS THE ADDRESS OF VALUE

LOOP  
	MOV R1,#32		; 32 BITS COUNTER
	LDR R0,[R6],#4		; GET THE 32 BIT VALUE

LOOP0	
	MOVS R0,R0,ROR #1 	; RIGHT SHIFT TO CHECK CARRY BIT (1's/0's)
	BHI ONES		; IF CARRY BIT IS 1 GOTO ONES BRANCH OTHERWISE NEXT

ZEROS	
	ADD R3,R3,#1		; IF CARRY BIT IS 0 THEN INCREMENT THE COUNTER BY 1(R3)
	
	B LOOP1			; BRANCH TO LOOP1

ONES	
	ADD R2,R2,#1		; IF CARRY BIT IS 1 THEN INCREMENT THE COUNTER BY 1(R2)

LOOP1	
	SUBS R1,R1,#1		; COUNTER VALUE DECREMENTED BY 1
	BNE LOOP0		; IF NOT EQUAL GOTO TO LOOP0 CHECKS 32BIT
		
	SUBS R7,R7,#1		; COUNTER VALUE DECREMENTED BY 1
  	CMP R7,#0		; COMPARE COUNTER R7 TO 0
	BNE LOOP		; IF NOT EQUAL GOTO TO LOOP

BACK  B BACK
		
VALUE DCD 0X11111111,0XAA55AA55;   TWO VALUES IN AN ARRAY 

	END			  ; Mark end of file